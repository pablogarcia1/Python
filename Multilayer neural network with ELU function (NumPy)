import numpy as np


def elu(x, alpha=0.7):
    return np.where(x >= 0, x, alpha * (np.exp(x) - 1))


def elu_prime(x, alpha=0.7):
    return np.where(x >= 0, 1, alpha * np.exp(x))


def forward_elu_3capas(x, W1, b1, W2, b2, W3, b3, alpha=0.7):
    z1 = np.dot(x, W1) + b1
    a1 = elu(z1, alpha)
    z2 = np.dot(a1, W2) + b2
    a2 = elu(z2, alpha)
    z3 = np.dot(a2, W3) + b3
    a3 = elu(z3, alpha)
    return z1, a1, z2, a2, z3, a3


def backward_elu_3capas(x, y, z1, a1, z2, a2, z3, a3, W1, b1, W2, b2, W3, b3, lr=0.09, alpha=0.7):
    error_output = a3 - y
    d_a3 = error_output * elu_prime(z3, alpha)
    grad_W3 = np.dot(a2.T, d_a3)
    grad_b3 = np.sum(d_a3, axis=0, keepdims=True)

    d_a2 = np.dot(d_a3, W3.T) * elu_prime(z2, alpha)
    grad_W2 = np.dot(a1.T, d_a2)
    grad_b2 = np.sum(d_a2, axis=0, keepdims=True)

    d_a1 = np.dot(d_a2, W2.T) * elu_prime(z1, alpha)
    grad_W1 = np.dot(x.T, d_a1)
    grad_b1 = np.sum(d_a1, axis=0, keepdims=True)

    W3 -= lr * grad_W3
    b3 -= lr * grad_b3
    W2 -= lr * grad_W2
    b2 -= lr * grad_b2
    W1 -= lr * grad_W1
    b1 -= lr * grad_b1

    return W1, b1, W2, b2, W3, b3


def ejemplo_3capas_elu_sin_bias_global_normalizado():
    np.random.seed(42)

    X_data = np.array([[7, 11], [14, 3], [5, 12], [2, 16]])
    Y_data = np.array([[4, 6], [17, 9], [8, 13], [7, 15]])

    X_min, X_max = X_data.min(axis=0), X_data.max(axis=0)
    X_norm = (X_data - X_min) / (X_max - X_min)

    Y_min, Y_max = Y_data.min(axis=0), Y_data.max(axis=0)
    Y_norm = (Y_data - Y_min) / (Y_max - Y_min)

    W1 = np.random.randn(2, 2) * np.sqrt(2 / 2)
    b1 = np.random.randn(1, 2) * 0.01
    W2 = np.random.randn(2, 2) * np.sqrt(2 / 2)
    b2 = np.random.randn(1, 2) * 0.01
    W3 = np.random.randn(2, 2) * np.sqrt(2 / 2)
    b3 = np.random.randn(1, 2) * 0.01

    lr = 0.5
    error_threshold = 1e-4
    maxEpochs = 50000

    for epoch in range(1, maxEpochs + 1):
        total_error = 0
        for i in range(X_norm.shape[0]):
            x = X_norm[i:i + 1]
            y = Y_norm[i:i + 1]

            z1, a1, z2, a2, z3, a3 = forward_elu_3capas(x, W1, b1, W2, b2, W3, b3)
            pattern_error = 0.5 * np.sum((a3 - y) ** 2)
            total_error += pattern_error

            W1, b1, W2, b2, W3, b3 = backward_elu_3capas(x, y, z1, a1, z2, a2, z3, a3, W1, b1, W2, b2, W3, b3, lr)

        if epoch % 100 == 0 or epoch == 1:
            print(f'Epoca: {epoch}: Error: {total_error}')

        if total_error < error_threshold:
            print(f'Numero total de epocas: {epoch} Error Total: {total_error:.6f}')
            break

    print('\n### Resultados Finales ###')
    print('Matriz de pesos W1:', W1, sep='\n')
    print('Bias b1:', b1, sep='\n')
    print('Matriz de pesos W2:', W2, sep='\n')
    print('Bias b2:', b2, sep='\n')
    print('Matriz de pesos W3:', W3, sep='\n')
    print('Bias b3:', b3, sep='\n')

    while True:
        user_input = input("x1 x2 : ")
        if user_input.lower() == 'a':
            print("Saliendo...")
            break

        user_values = np.array(user_input.split(), dtype=float)
        if user_values.shape[0] != 2:
            print("Algo no cuadra, intenta otra vez con dos nÃºmeros.")
            continue

        x = (user_values - X_min) / (X_max - X_min)
        _, _, _, _, _, a3_norm = forward_elu_3capas(x, W1, b1, W2, b2, W3, b3)
        a3_denorm = a3_norm * (Y_max - Y_min) + Y_min

        print(f'Input: {user_values}, Predicted: {a3_denorm}')



